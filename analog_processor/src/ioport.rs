#[path = "./arithmetic_logic_unit.rs"]
mod arithmetic_logic_unit;

const CYCLE_TIME_MICROSECONDS: usize = 4;
const OPCODE_LENGTH: usize = 4;

//Called by processor
pub fn recieve_commands(commands: Vec<String> ) {
    println!("----------");
    let mut registers: Vec<f64> = vec![0.0; 16];
    let mut run_time_microseconds = 0;
    let mut transferres = 0;
    let mut program_counter: usize = "0".parse::<usize>().expect("Not a number!");
    let done = false;
    //Run Cycles 
    while done == false {
        //Check for noise generated over time 
        run_time_microseconds = run_time_microseconds + CYCLE_TIME_MICROSECONDS;

        let opcode = truncate(&commands[program_counter], OPCODE_LENGTH);
        //Check for noise generated by transferre
        //RETHINK THIS BECASUE ONLY A FEW COMMANDS ARENT MOVES (+ / - * TRANSERRES TOO)
        if opcode != "JUMP"{
            transferres = transferres + 1;
        }
        if opcode == "NOP"{
            println!("Run command {}", opcode);
            println!("Stopping");
            println!("----------");
            println!("Finished");
            print!("Registers: ");
            for register in registers {
                print!("{}, ", register.to_string())
            }
            println!("");
            println!("Runtime in micro seconds {} with {} transferres", run_time_microseconds, transferres);
            break;
        }
        //Run a cycle
        arithmetic_logic_unit::run_cycle(&commands[program_counter], &mut registers, &mut program_counter);
    }
}

pub fn truncate(s: &str, max_chars: usize) -> &str {
    match s.char_indices().nth(max_chars) {
        None => s,
        Some((idx, _)) => &s[..idx],
    }
}